<!DOCTYPE html>
<html>
<head>
<title>Flappy Yellow</title>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<style>
  :root { --sky:#70c5ce; --ink:#000; --panel-bg:rgba(255,255,255,0.9); }
  body { margin:0; background:var(--sky); overflow:hidden; font-family:system-ui,Arial,Helvetica,sans-serif; }
  canvas { display:block; margin:0 auto; background:var(--sky); }

  /* UI overlays */
  .hud {
    position:fixed; left:12px; top:10px; z-index:5; color:#000; user-select:none;
    text-shadow:0 1px 0 rgba(255,255,255,0.6);
  }
  .hud .line { font-size:18px; line-height:1.15; }
  .btn {
    position:fixed; right:12px; top:12px; z-index:6;
    background:#fff; border:1px solid #ddd; border-radius:10px; padding:8px 12px; cursor:pointer;
    box-shadow:0 2px 6px rgba(0,0,0,0.08);
  }
  .btn:active { transform:translateY(1px); }
  .panel {
    position:fixed; right:12px; top:52px; width:280px; max-width:90vw; z-index:7;
    background:var(--panel-bg); border:1px solid #e8e8e8; border-radius:14px; box-shadow:0 8px 24px rgba(0,0,0,0.12);
    backdrop-filter:saturate(1.2) blur(4px);
    display:none;
  }
  .panel header { padding:10px 12px; font-weight:700; border-bottom:1px solid #eaeaea; }
  .panel .content { max-height:55vh; overflow:auto; }
  .panel table { width:100%; border-collapse:collapse; font-size:14px; }
  .panel th, .panel td { padding:8px 10px; border-bottom:1px solid #efefef; text-align:left; }
  .pill {
    display:inline-block; padding:2px 8px; border-radius:999px; background:#f3f3f3; font-size:12px; margin-left:6px;
  }
  .footer { padding:8px 12px; font-size:12px; color:#333; }
</style>
</head>
<body>
<button id="toggleBoard" class="btn">üèÜ Leaderboard</button>
<div id="board" class="panel" aria-hidden="true">
  <header>Global Top 10 <span id="onlineStatus" class="pill">offline</span></header>
  <div class="content">
    <table id="boardTable">
      <thead><tr><th>#</th><th>Name</th><th>Score</th></tr></thead>
      <tbody></tbody>
    </table>
  </div>
  <div class="footer">
    You: <strong id="meName">‚Äî</strong> ‚Ä¢ Best: <strong id="meBest">0</strong> ‚Ä¢ Rank: <strong id="meRank">‚Äî</strong>
  </div>
</div>

<div class="hud">
  <div class="line" id="hudName">Player: ‚Äî</div>
  <div class="line" id="hudHigh">High: 0</div>
  <div class="line" id="hudScore">Score: 0</div> <!-- added to prevent overlap -->
</div>

<canvas id="gameCanvas"></canvas>

<!-- Optional Firebase (Online Leaderboard). Safe to keep even if unused. -->
<script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-database-compat.js"></script>

<script>
/* ===========================
   CONFIG: Fill only if you want ONLINE ranking.
   Leave as-is for local-only; the game will still run with no errors.
=========================== */
const FIREBASE_CONFIG = {
  apiKey: "",              // <-- paste from Firebase console
  authDomain: "",
  databaseURL: "",         // e.g. https://your-project-id-default-rtdb.firebaseio.com
  projectId: "",
  storageBucket: "",
  messagingSenderId: "",
  appId: ""
};
const ONLINE_ENABLED = Object.values(FIREBASE_CONFIG).some(Boolean);

/* ===========================
   Basic Game Setup
=========================== */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
function resize(){ canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
window.addEventListener('resize', resize);
resize();

let bird = { x: 120, y: canvas.height/2, radius: 16, gravity: 0.45, lift: -8, velocity: 0 };
let pipes = [];
let frame = 0;
let score = 0;
let gameOver = false;

// üå•Ô∏è Clouds array
let clouds = [];
for (let i = 0; i < 8; i++) {
  clouds.push({
    x: Math.random() * canvas.width,
    y: Math.random() * (canvas.height / 2),
    size: 40 + Math.random() * 60,
    speed: 0.3 + Math.random() * 0.5
  });
}

// üçá Collectibles array
let collectibles = [];
let collectibleCooldown = 0; // cooldown tracker

// ======= High Score + Player Name (Local) =======
const LS_HIGH = 'flappy_highscore';
const LS_NAME = 'flappy_username';
function getName(){
  let n = localStorage.getItem(LS_NAME);
  if(!n){
    n = prompt("Enter a nickname for the leaderboard:", "Player") || "Player";
    n = (""+n).slice(0,20).trim() || "Player";
    localStorage.setItem(LS_NAME, n);
  }
  return n;
}
function getHigh(){ return Number(localStorage.getItem(LS_HIGH) || 0); }
function setHigh(v){ localStorage.setItem(LS_HIGH, String(v)); }

let playerName = getName();
let localHigh = getHigh();
const hudName = document.getElementById('hudName');
const hudHigh = document.getElementById('hudHigh');
const hudScore = document.getElementById('hudScore'); // NEW
hudName.textContent = "Player: " + playerName;
aredHigh = "High: " + localHigh;
// fixed typo
hudHigh.textContent = "High: " + localHigh;
hudScore.textContent = "Score: 0"; // init score line

// ======= Leaderboard UI =======
const toggleBtn = document.getElementById('toggleBoard');
const board = document.getElementById('board');
const boardBody = document.querySelector('#boardTable tbody');
const meNameEl = document.getElementById('meName');
const meBestEl = document.getElementById('meBest');
const meRankEl = document.getElementById('meRank');
const onlineStatus = document.getElementById('onlineStatus');

toggleBtn.addEventListener('click', ()=>{
  const open = board.style.display === 'block';
  board.style.display = open ? 'none' : 'block';
  board.setAttribute('aria-hidden', open ? 'true' : 'false');
  if (!open) refreshLeaderboard().catch(()=>{});
});

/* ===========================
   Online Leaderboard (Firebase-ready)
=========================== */
let fb = { app:null, db:null, ok:false };

function safeSetOnlineStatus() {
  onlineStatus.textContent = fb.ok ? 'online' : 'offline';
  onlineStatus.style.background = fb.ok ? '#d9fadd' : '#f3f3f3';
}

function initOnline(){
  try{
    if (!ONLINE_ENABLED) { fb.ok=false; safeSetOnlineStatus(); return; }
    fb.app = firebase.initializeApp(FIREBASE_CONFIG);
    fb.db = firebase.database();
    fb.ok = true;
  }catch(e){
    console.warn('Online disabled:', e);
    fb.ok = false;
  }
  safeSetOnlineStatus();
}
initOnline();

// Push score (name, score, ts). Errors are swallowed to avoid breaking the game.
async function pushScore(name, value){
  if (!fb.ok) return;
  try{
    const ref = fb.db.ref('flappy_yellow/leaderboard').push();
    await ref.set({ name, score:value, ts: Date.now() });
  }catch(e){ console.warn('pushScore failed', e); }
}

// Fetch top N (default 10). Returns [{name,score}] high->low.
async function fetchTopN(n=10){
  if (!fb.ok) return [];
  try{
    const snap = await fb.db.ref('flappy_yellow/leaderboard')
      .orderByChild('score').limitToLast(n).get();
    const arr = [];
    snap.forEach(child => arr.push(child.val()));
    // limitToLast returns ascending; reverse to descending
    arr.sort((a,b)=>b.score - a.score);
    return arr;
  }catch(e){
    console.warn('fetchTopN failed', e);
    return [];
  }
}

// Try to estimate your rank by comparing against top K; if score is below the shown list, show "1000+"
async function estimateMyRank(myBest){
  if (!fb.ok) return '‚Äî';
  try{
    const top = await fetchTopN(100);
    if (top.length === 0) return '‚Äî';
    let rank = 1;
    for (const row of top){
      if (myBest < row.score) rank++;
    }
    // If we're worse than the last shown, show "100+"
    if (rank > top.length) return (top.length + '+');
    return String(rank);
  }catch(e){ return '‚Äî'; }
}

async function refreshLeaderboard(){
  meNameEl.textContent = playerName;
  meBestEl.textContent = localHigh;
  meRankEl.textContent = fb.ok ? '‚Ä¶' : '‚Äî';

  // Load top 10
  let rows = [];
  try{
    rows = await fetchTopN(10);
  }catch(e){ rows = []; }

  boardBody.innerHTML = '';
  if (rows.length === 0){
    const tr = document.createElement('tr');
    const td = document.createElement('td');
    td.colSpan = 3; td.textContent = fb.ok ? 'No scores yet.' : 'Online disabled.';
    tr.appendChild(td); boardBody.appendChild(tr);
  } else {
    rows.forEach((r, i)=>{
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${i+1}</td><td>${escapeHtml(r.name||'Player')}</td><td>${r.score|0}</td>`;
      boardBody.appendChild(tr);
    });
  }

  // Rank estimate
  const rk = await estimateMyRank(localHigh);
  meRankEl.textContent = rk;
}

function escapeHtml(s){
  return (''+s).replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;' }[m]));
}

/* ===========================
   Game Rendering / Logic (unchanged gameplay)
=========================== */

// ‚≠ê Draw a purple collectible
function drawCollectible(item){
  ctx.beginPath();
  ctx.arc(item.x, item.y, item.radius, 0, Math.PI*2);
  ctx.fillStyle = '#8a2be2'; // purple
  ctx.fill();
  ctx.lineWidth = 2;
  ctx.strokeStyle = '#ffffff';
  ctx.stroke();
}

// ‚≠ê Controlled collectible spawn logic
function spawnCollectiblesRandom(px, top, gap, width){
  if (collectibleCooldown > 0) {
    collectibleCooldown--;
    return;
  }
  const midY = top + gap / 2;
  const jitter = () => (Math.random()*2-1) * (gap * 0.25);
  collectibles.push({ x: px + width/2, y: midY + jitter(), radius: 9 });
  collectibleCooldown = Math.floor(Math.random() * 4) + 1; // 1‚Äì4 pipes
}

function playSound(freq, duration) {
  try{
    const ctxAudio = new (window.AudioContext || window.webkitAudioContext)();
    const osc = ctxAudio.createOscillator();
    const gain = ctxAudio.createGain();
    osc.connect(gain); gain.connect(ctxAudio.destination);
    osc.type = 'sine'; osc.frequency.setValueAtTime(freq, ctxAudio.currentTime);
    gain.gain.setValueAtTime(0.05, ctxAudio.currentTime);
    osc.start(); osc.stop(ctxAudio.currentTime + duration);
  }catch(e){/* audio not available */}
}

function drawBird(){
  const x = bird.x, y = bird.y, r = bird.radius;
  const angle = Math.max(-0.6, Math.min(0.8, bird.velocity / 15));
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);

  ctx.beginPath();
  ctx.ellipse(0, 0, r * 1.15, r, 0, 0, Math.PI * 2);
  ctx.fillStyle = '#FFD344';
  ctx.fill();
  ctx.lineWidth = 1;
  ctx.strokeStyle = 'rgba(0,0,0,0.08)';
  ctx.stroke();

  ctx.save();
  ctx.translate(-4, 2);
  ctx.rotate(-0.4);
  ctx.beginPath();
  ctx.ellipse(0, 0, r*0.7, r*0.45, 0, 0, Math.PI*2);
  ctx.fillStyle = '#F4C542';
  ctx.fill();
  ctx.restore();

  ctx.beginPath();
  ctx.moveTo(-r*1.1, 2);
  ctx.lineTo(-r*1.6, -4);
  ctx.lineTo(-r*1.6, 8);
  ctx.closePath();
  ctx.fillStyle = '#F2B83A';
  ctx.fill();

  ctx.beginPath();
  ctx.moveTo(r*0.9, -3);
  ctx.lineTo(r*1.6, -6);
  ctx.lineTo(r*1.6, 2);
  ctx.closePath();
  ctx.fillStyle = '#FF9B2F';
  ctx.fill();

  ctx.beginPath(); ctx.fillStyle = '#fff'; ctx.arc(r*0.35, -r*0.25, r*0.38, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.fillStyle = '#000'; ctx.arc(r*0.45, -r*0.25, r*0.18, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.fillStyle = 'rgba(255,255,255,0.9)'; ctx.arc(r*0.35, -r*0.35, r*0.08, 0, Math.PI*2); ctx.fill();

  ctx.restore();
}

function drawPipes(){
  ctx.fillStyle = '#2c8b2c';
  ctx.strokeStyle = '#1f6f1f';
  ctx.lineWidth = 4;
  for (let p of pipes){
    roundRect(ctx, p.x, 0, p.width, p.top, 10, true, false, '#2c8b2c');
    ctx.fillStyle = '#1f6f1f'; ctx.fillRect(p.x-6, p.top-12, p.width+12, 12);
    roundRect(ctx, p.x, canvas.height - p.bottom, p.width, p.bottom, 10, true, false, '#2c8b2c');
    ctx.fillStyle = '#1f6f1f'; ctx.fillRect(p.x-6, canvas.height - p.bottom, p.width+12, 12);
  }
}

function roundRect(ctx, x, y, w, h, r, fill, stroke, forcedFill){
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
  if (forcedFill) ctx.fillStyle = forcedFill;
  if (fill) ctx.fill();
  if (stroke) ctx.stroke();
}

function drawScore(){
  // Update the HUD line instead of drawing on the canvas to avoid overlap
  hudScore.textContent = 'Score: ' + score;
}

function drawGameOver(){
  ctx.fillStyle = 'black';
  ctx.font = '48px Arial';
  ctx.textAlign = 'center';
  ctx.fillText('Game Over', canvas.width/2, canvas.height/2 - 20);
  ctx.font = '24px Arial';
  ctx.fillText('Tap / Click / Space to Restart', canvas.width/2, canvas.height/2 + 18);
  ctx.textAlign = 'start';
}

function drawCloud(cx, cy, size) {
  ctx.fillStyle = "white";
  ctx.beginPath();
  ctx.arc(cx, cy, size * 0.4, 0, Math.PI * 2);
  ctx.arc(cx + size * 0.4, cy - size * 0.2, size * 0.35, 0, Math.PI * 2);
  ctx.arc(cx + size * 0.8, cy, size * 0.4, 0, Math.PI * 2);
  ctx.arc(cx + size * 0.4, cy + size * 0.2, size * 0.35, 0, Math.PI * 2);
  ctx.fill();
}

function update(){
  if (gameOver) return;

  for (let c of clouds) {
    c.x -= c.speed;
    if (c.x < -c.size * 2) {
      c.x = canvas.width + c.size;
      c.y = Math.random() * (canvas.height / 2);
      c.size = 40 + Math.random() * 60;
      c.speed = 0.3 + Math.random() * 0.5;
    }
  }

  bird.velocity += bird.gravity;
  bird.y += bird.velocity;

  if (frame % 100 === 0){
    const GAP = 180;
    const top = Math.random() * (canvas.height - GAP - 140) + 60;
    const bottom = canvas.height - top - GAP;
    pipes.push({ x: canvas.width + 20, width: 72, top: top, bottom: bottom, passed: false });

    const last = pipes[pipes.length - 1];
    spawnCollectiblesRandom(last.x, top, GAP, last.width);
  }

  for (let i = pipes.length -1; i >= 0; i--){
    const p = pipes[i];
    p.x -= 3.2;
    if (!p.passed && p.x + p.width < bird.x - bird.radius){ p.passed = true; score++; }
    if (p.x + p.width < -50) pipes.splice(i,1);
    if (circleRectCollision(bird.x, bird.y, bird.radius, p.x, 0, p.width, p.top) ||
        circleRectCollision(bird.x, bird.y, bird.radius, p.x, canvas.height - p.bottom, p.width, p.bottom)){
      gameOver = true; playSound(140, 0.18);
      onGameOver();
    }
  }

  for (let i = collectibles.length - 1; i >= 0; i--){
    const it = collectibles[i];
    it.x -= 3.2;
    const dx = bird.x - it.x;
    const dy = bird.y - it.y;
    const rr = bird.radius + it.radius;
    if (dx*dx + dy*dy < rr*rr){
      score += 10;
      playSound(620, 0.1);
      collectibles.splice(i, 1);
      continue;
    }
    if (it.x < -it.radius - 10) collectibles.splice(i, 1);
  }

  const margin = 4;
  if (bird.y - bird.radius < -margin) { bird.y = -margin + bird.radius; bird.velocity = 0; }
  if (bird.y + bird.radius > canvas.height - margin){
    bird.y = canvas.height - margin - bird.radius; bird.velocity = 0; gameOver = true; playSound(140,0.18);
    onGameOver();
  }

  frame++;
}

function onGameOver(){
  // Update local high score
  if (score > localHigh){
    localHigh = score;
    setHigh(localHigh);
    hudHigh.textContent = "High: " + localHigh;
  }
  // Push to online (if enabled)
  pushScore(playerName, localHigh);
  // Update panel footer immediately
  meNameEl.textContent = playerName;
  meBestEl.textContent = localHigh;
  estimateMyRank(localHigh).then(r=>{ meRankEl.textContent = r; }).catch(()=>{});
}

function circleRectCollision(cx, cy, cr, rx, ry, rw, rh){
  const closestX = Math.max(rx, Math.min(cx, rx + rw));
  const closestY = Math.max(ry, Math.min(cy, ry + rh));
  const dx = cx - closestX; const dy = cy - closestY;
  return (dx*dx + dy*dy) < (cr*cr);
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const g = ctx.createLinearGradient(0,0,0,canvas.height);
  g.addColorStop(0, '#bfefff'); g.addColorStop(1,'#70c5ce');
  ctx.fillStyle = g; ctx.fillRect(0,0,canvas.width,canvas.height);

  for (let c of clouds) {
    drawCloud(c.x, c.y, c.size);
  }

  drawPipes();

  for (let it of collectibles){
    drawCollectible(it);
  }

  drawBird();
  drawScore();
  if (gameOver) drawGameOver();
}

function loop(){ update(); draw(); requestAnimationFrame(loop); }

function flap(){
  if (gameOver){
    bird = { x: 120, y: canvas.height/2, radius: 16, gravity: 0.45, lift: -8, velocity: 0 };
    pipes = []; frame = 0; score = 0; gameOver = false;
    collectibles = []; collectibleCooldown = 0;
    return;
  }
  bird.velocity = bird.lift;
  playSound(420, 0.08);
}

window.addEventListener('mousedown', flap);
window.addEventListener('touchstart', e=>{ e.preventDefault(); flap(); }, {passive:false});
window.addEventListener('keydown', e=>{ if (e.code === 'Space') flap(); });

loop();
</script>
</body>
</html>
